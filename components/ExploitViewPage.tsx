import React, { useState, useCallback, useRef, useEffect, useMemo } from 'react';
import { ExcelWorkbook, ExcelSheet, ExploitFolder } from '../types';
import ConfirmModal from './ConfirmModal'; 

// --- SVG Icons ---
const UploadIcon: React.FC<React.SVGProps<SVGSVGElement>> = (props) => <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}><path strokeLinecap="round" strokeLinejoin="round" d="M12 16.5V9.75m0 0l-3.75 3.75M12 9.75l3.75 3.75M17.25 8.25L21 12m0 0l-3.75 3.75M21 12H3" /></svg>;
const FolderIcon: React.FC<React.SVGProps<SVGSVGElement>> = (props) => <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}><path strokeLinecap="round" strokeLinejoin="round" d="M2.25 12.75V12A2.25 2.25 0 014.5 9.75h15A2.25 2.25 0 0121.75 12v.75m-8.69-6.44l-2.12-2.12a1.5 1.5 0 00-1.061-.44H4.5A2.25 2.25 0 002.25 6v12a2.25 2.25 0 002.25 2.25h15A2.25 2.25 0 0021.75 18V9a2.25 2.25 0 00-2.25-2.25h-5.379a1.5 1.5 0 01-1.06-.44z" /></svg>;
const FolderOpenIcon: React.FC<React.SVGProps<SVGSVGElement>> = (props) => <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}><path strokeLinecap="round" strokeLinejoin="round" d="M13.5 10.5L12 9m0 0L10.5 7.5M12 9l1.5-1.5M12 9V3.75m0 5.25A2.25 2.25 0 0014.25 12H16.5a2.25 2.25 0 012.25 2.25v2.25A2.25 2.25 0 0116.5 19.5h-9A2.25 2.25 0 015.25 16.5v-2.25A2.25 2.25 0 017.5 12h2.25a2.25 2.25 0 002.25-2.25z" /></svg>;
const DocumentIcon: React.FC<React.SVGProps<SVGSVGElement>> = (props) => <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}><path strokeLinecap="round" strokeLinejoin="round" d="M19.5 14.25v-2.625a3.375 3.375 0 00-3.375-3.375h-1.5A1.125 1.125 0 0113.5 7.125v-1.5a3.375 3.375 0 00-3.375-3.375H8.25m2.25 0H5.625c-.621 0-1.125.504-1.125 1.125v17.25c0 .621.504 1.125 1.125 1.125h12.75c.621 0 1.125-.504-1.125 1.125V11.25a9 9 0 00-9-9z" /></svg>;
const ChevronDownIcon: React.FC<React.SVGProps<SVGSVGElement>> = (props) => <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}><path strokeLinecap="round" strokeLinejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5" /></svg>;
const ChevronUpIcon: React.FC<React.SVGProps<SVGSVGElement>> = (props) => <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}><path strokeLinecap="round" strokeLinejoin="round" d="M4.5 15.75l7.5-7.5 7.5 7.5" /></svg>;
const InformationCircleIcon: React.FC<React.SVGProps<SVGSVGElement>> = (props) => <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}><path strokeLinecap="round" strokeLinejoin="round" d="M11.25 11.25l.041-.02a.75.75 0 011.063.852l-.708 2.836a.75.75 0 001.063.853l.041-.021M21 12a9 9 0 11-18 0 9 9 0 0118 0zm-9-3.75h.008v.008H12V8.25z" /></svg>;
const TrashIcon: React.FC<React.SVGProps<SVGSVGElement>> = (props) => <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}><path strokeLinecap="round" strokeLinejoin="round" d="M14.74 9l-.346 9m-4.788 0L9.26 9m9.968-3.21c.342.052.682.107 1.022.166m-1.022-.165L18.16 19.673a2.25 2.25 0 01-2.244 2.077H8.084a2.25 2.25 0 01-2.244-2.077L4.772 5.79m14.456 0a48.108 48.108 0 00-3.478-.397m-12.56 0c1.153 0 2.243.096 3.297.266M6.937 9.043c.626-.169 1.282-.296 1.968-.376M14.063 9.043c.626-.169 1.282-.296 1.968-.376" /></svg>;
const XMarkIcon: React.FC<React.SVGProps<SVGSVGElement>> = (props) => <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}><path strokeLinecap="round" strokeLinejoin="round" d="M6 18L18 6M6 6l12 12" /></svg>;
const EditIcon: React.FC<React.SVGProps<SVGSVGElement>> = (props) => <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}><path strokeLinecap="round" strokeLinejoin="round" d="M16.862 4.487l1.687-1.688a1.875 1.875 0 112.652 2.652L10.582 16.07a4.5 4.5 0 01-1.897 1.13L6 18l.8-2.685a4.5 4.5 0 011.13-1.897l8.932-8.931zm0 0L19.5 7.125M18 14v4.75A2.25 2.25 0 0115.75 21H5.25A2.25 2.25 0 013 18.75V8.25A2.25 2.25 0 015.25 6H10" /></svg>;
const SaveIcon: React.FC<React.SVGProps<SVGSVGElement>> = (props) => <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}><path strokeLinecap="round" strokeLinejoin="round" d="M4.5 12.75l6 6 9-13.5" /></svg>;
const DownloadIcon: React.FC<React.SVGProps<SVGSVGElement>> = (props) => <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}><path strokeLinecap="round" strokeLinejoin="round" d="M3 16.5v2.25A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75V16.5M16.5 12L12 16.5m0 0L7.5 12m4.5 4.5V3" /></svg>;
const ArchiveBoxArrowDownIcon: React.FC<React.SVGProps<SVGSVGElement>> = (props) => <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}><path strokeLinecap="round" strokeLinejoin="round" d="M3 16.5v2.25A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75V16.5M16.5 12L12 16.5m0 0L7.5 12m4.5 4.5V3M3.75 5.875c0-.621.504-1.125 1.125-1.125h14.25c.621 0 1.125.504 1.125 1.125v3.375c0 .621-.504 1.125-1.125 1.125H4.875c-.621 0-1.125-.504-1.125-1.125V5.875z" /></svg>;

// --- End SVG Icons ---

const EXPLOIT_VIEW_FOLDERS_KEY = 'exploitViewFoldersData';

const generateId = (): string => {
  if (typeof crypto !== 'undefined' && crypto.randomUUID) {
    return crypto.randomUUID();
  }
  console.warn("crypto.randomUUID not available, using fallback ID generator. This is not recommended for production.");
  return `fallback-${Date.now()}-${Math.random().toString(36).substring(2, 15)}`;
};

interface ConfirmModalInfo { 
  title: string;
  message: string;
  onConfirmAction: () => void;
}

export const ExploitViewPage: React.FC = () => {
  const [folders, setFolders] = useState<ExploitFolder[]>([]);
  const [expandedFolderId, setExpandedFolderId] = useState<string | null>(null);
  const [expandedWorkbookId, setExpandedWorkbookId] = useState<string | null>(null);
  
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [successMessage, setSuccessMessage] = useState<string | null>(null);
  
  const [showFolderModal, setShowFolderModal] = useState(false);
  const [selectedFileForUpload, setSelectedFileForUpload] = useState<File | null>(null);
  const [targetFolderName, setTargetFolderName] = useState('');

  const [editingFolderId, setEditingFolderId] = useState<string | null>(null);
  const [newFolderNameInput, setNewFolderNameInput] = useState('');

  const [showConfirmModal, setShowConfirmModal] = useState(false);
  const [confirmModalInfo, setConfirmModalInfo] = useState<ConfirmModalInfo | null>(null);

  const [selectedSheetsForExport, setSelectedSheetsForExport] = useState<Record<string, Record<string, boolean>>>({});

  const fileInputRef = useRef<HTMLInputElement>(null);
  const folderNameInputRef = useRef<HTMLInputElement>(null);
  const editFolderNameInputRef = useRef<HTMLInputElement>(null);

  useEffect(() => {
    try {
      const storedFoldersJson = localStorage.getItem(EXPLOIT_VIEW_FOLDERS_KEY);
      if (storedFoldersJson) {
        const parsedFolders: ExploitFolder[] = JSON.parse(storedFoldersJson);
        const hydratedFolders = parsedFolders.map(folder => ({
          ...folder,
          createdAt: new Date(folder.createdAt),
          workbooks: folder.workbooks.map(workbook => ({
            ...workbook,
            uploadedAt: new Date(workbook.uploadedAt),
            sheets: workbook.sheets.map(sheet => ({
                 ...sheet, 
                 worksheet: null // Raw worksheet objects are not stored in localStorage
            }))
          })),
        }));
        setFolders(hydratedFolders);
      }
    } catch (e) {
      console.error("Failed to load or parse folders from localStorage:", e);
      setError("Could not load previously saved data. Starting fresh.");
      localStorage.removeItem(EXPLOIT_VIEW_FOLDERS_KEY);
    }
  }, []);

  useEffect(() => {
    try {
      const serializableFolders = folders.map(folder => ({
        ...folder,
        workbooks: folder.workbooks.map(workbook => ({
          ...workbook,
          sheets: workbook.sheets.map(sheet => {
            const { worksheet, ...restOfSheet } = sheet; // Exclude non-serializable worksheet
            return restOfSheet;
          })
        }))
      }));
      localStorage.setItem(EXPLOIT_VIEW_FOLDERS_KEY, JSON.stringify(serializableFolders));
    } catch (e) {
      console.error("Failed to save folders to localStorage:", e);
      // Potentially alert user or implement more robust error handling for storage issues.
    }
  }, [folders]);


  useEffect(() => {
    if (successMessage) {
      const timer = setTimeout(() => setSuccessMessage(null), 5000);
      return () => clearTimeout(timer);
    }
  }, [successMessage]);

  useEffect(() => {
    if (error) {
      const timer = setTimeout(() => setError(null), 8000); 
      return () => clearTimeout(timer);
    }
  }, [error]);
  
  useEffect(() => {
    if (showFolderModal && folderNameInputRef.current) {
        folderNameInputRef.current.focus();
    }
  }, [showFolderModal]);
  
  useEffect(() => {
    if (editingFolderId && editFolderNameInputRef.current) {
      editFolderNameInputRef.current.focus();
      editFolderNameInputRef.current.select();
    }
  }, [editingFolderId]);

  useEffect(() => {
    if (expandedFolderId && !folders.some(f => f.id === expandedFolderId)) {
        setExpandedFolderId(null);
    }
    if (expandedWorkbookId) {
        const workbookStillExists = folders.some(folder => 
            folder.workbooks.some(wb => wb.id === expandedWorkbookId)
        );
        if (!workbookStillExists) {
            setExpandedWorkbookId(null);
        }
    }
  }, [folders, expandedFolderId, expandedWorkbookId]);

  const openConfirmationModal = (title: string, message: string, onConfirmAction: () => void) => {
    setConfirmModalInfo({ title, message, onConfirmAction });
    setShowConfirmModal(true);
  };

  const handleFileSelect = useCallback((event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file) return;
    setSelectedFileForUpload(file);
    setTargetFolderName(''); 
    setShowFolderModal(true);
    setError(null);
    setSuccessMessage(null);
  }, []);

  const handleConfirmUploadWithFolder = useCallback(async () => {
    if (!selectedFileForUpload || !targetFolderName.trim()) {
      setError("File and folder name are required.");
      return;
    }
    setIsLoading(true);
    setError(null);
    setSuccessMessage(null);
    setShowFolderModal(false);
    try {
      const reader = new FileReader();
      const fileData = await new Promise<ArrayBuffer>((resolve, reject) => {
        reader.onload = (e) => resolve(e.target?.result as ArrayBuffer);
        reader.onerror = () => reject(new Error("Failed to read file."));
        reader.readAsArrayBuffer(selectedFileForUpload);
      });

      const xlsxLibrary = window.XLSX; 
      if (!xlsxLibrary) throw new Error("XLSX library not loaded.");
      const jspdfLibrary = window.jspdf;
      if (!jspdfLibrary || !jspdfLibrary.jsPDF) throw new Error("jsPDF library not loaded.");

      // Parse Excel for data and PDF generation
      // Use cellStyles: true for formatting and bookFiles: true for images attempt
      const xlsxWorkbook = xlsxLibrary.read(fileData, { type: 'array', cellStyles: true, bookFiles: true });
      
      // --- PDF Generation ---
      const pdf = new jspdfLibrary.jsPDF();
      let pdfGenerated = false;
      xlsxWorkbook.SheetNames.forEach((sheetName, index) => {
        const worksheet = xlsxWorkbook.Sheets[sheetName];
        const aoaData: any[][] = xlsxLibrary.utils.sheet_to_json(worksheet, { header: 1, defval: null });
        
        if (aoaData.length > 0) {
            if (index > 0) pdf.addPage();
            pdf.text(sheetName, 14, 15); // Sheet name as title
            (pdf as any).autoTable({ // Cast to any to access autoTable plugin
              head: aoaData[0] ? [aoaData[0]] : [], // Header row
              body: aoaData.length > 1 ? aoaData.slice(1) : [], // Data rows
              startY: 20,
              theme: 'grid',
              styles: { fontSize: 8, cellPadding: 1.5, overflow: 'linebreak' },
              headStyles: { fillColor: [22, 160, 133], fontSize: 9, fontStyle: 'bold' },
              columnStyles: { 
                  0: { cellWidth: 'auto' }, 
              },
              didParseCell: function (data: any) { 
                  const cellText = String(data.cell.raw);
                  if (cellText.length > 100) { 
                      data.cell.text = cellText.substring(0, 97) + '...';
                  }
              }
            });
            pdfGenerated = true;
        }
      });

      if (pdfGenerated) {
        pdf.save(`${selectedFileForUpload.name.replace(/\.(xlsx?|xls)$/i, '')}_preview.pdf`);
      }
      // --- End PDF Generation ---

      const newSheets: ExcelSheet[] = [];
      xlsxWorkbook.SheetNames.forEach(sheetName => {
        const worksheet = xlsxWorkbook.Sheets[sheetName];
        // Log for diagnosing image parsing
        console.log("Worksheet", sheetName, "!images property:", worksheet['!images']); 
        
        const sheetDataArray: any[][] = xlsxLibrary.utils.sheet_to_json(worksheet, { header: 1, defval: null });
        const headers: string[] = sheetDataArray.length > 0 ? sheetDataArray[0].map(String) : [];
        const dataRows: (string | number | boolean | null)[][] = sheetDataArray.length > 1 ? sheetDataArray.slice(1) : [];
        newSheets.push({ 
          name: sheetName, 
          headers, 
          data: dataRows,
          worksheet: worksheet // Store the raw worksheet object for potential rich export
        });
      });

      if (newSheets.length === 0) throw new Error("No sheets found in the Excel file.");
      
      const newWorkbook: ExcelWorkbook = {
        id: generateId(),
        fileName: selectedFileForUpload.name,
        sheets: newSheets,
        uploadedAt: new Date(),
      };

      const normalizedTargetFolderName = targetFolderName.trim().toLowerCase();
      const originalDisplayFolderName = targetFolderName.trim();
      let targetFolderIdToExpand: string | null = null;

      setFolders(prevFolders => {
        const existingFolderIndex = prevFolders.findIndex(f => f.name.toLowerCase() === normalizedTargetFolderName);
        if (existingFolderIndex > -1) {
          const updatedFolders = [...prevFolders];
          const updatedFolder = { ...updatedFolders[existingFolderIndex] };
          updatedFolder.workbooks = [...updatedFolder.workbooks, newWorkbook].sort((a,b) => a.fileName.localeCompare(b.fileName));
          updatedFolders[existingFolderIndex] = updatedFolder;
          targetFolderIdToExpand = updatedFolder.id;
          return updatedFolders;
        } else {
          const newFolder: ExploitFolder = {
            id: generateId(),
            name: normalizedTargetFolderName, 
            originalName: originalDisplayFolderName, 
            workbooks: [newWorkbook],
            createdAt: new Date(),
          };
          targetFolderIdToExpand = newFolder.id;
          return [...prevFolders, newFolder].sort((a,b) => a.originalName.localeCompare(b.originalName));
        }
      });

      if(targetFolderIdToExpand) setExpandedFolderId(targetFolderIdToExpand);
      let successMsg = `Workbook "${selectedFileForUpload.name}" processed for Exploit View.`;
      if (pdfGenerated) {
        successMsg += " A PDF preview has been downloaded.";
      } else {
        successMsg += " No data found to generate a PDF preview.";
      }
      setSuccessMessage(successMsg);

    } catch (err) {
      console.error("File upload/parsing/PDF generation error:", err);
      setError(err instanceof Error ? err.message : 'Failed to process file and generate PDF.');
    } finally {
      setIsLoading(false);
      setSelectedFileForUpload(null);
      setTargetFolderName('');
      if (fileInputRef.current) fileInputRef.current.value = "";
    }
  }, [selectedFileForUpload, targetFolderName]);
  
  const handleDeleteFolder = useCallback((folderIdToDelete: string, folderName: string) => {
    if (!folderIdToDelete) {
        setError("Cannot delete folder: Invalid folder ID.");
        return;
    }
    openConfirmationModal(
        "Delete Folder",
        `Are you sure you want to delete the folder "${folderName}" and all its workbooks? This action cannot be undone.`,
        () => {
            const folderBeingDeleted = folders.find(f => f.id === folderIdToDelete);
            setFolders(prevFolders => prevFolders.filter(f => f.id !== folderIdToDelete));
            setSuccessMessage(`Folder "${folderName}" deleted successfully.`);
            if (expandedFolderId === folderIdToDelete) {
              setExpandedFolderId(null);
              setExpandedWorkbookId(null);
            }
            if (folderBeingDeleted) {
                setSelectedSheetsForExport(prev => {
                    const newState = {...prev};
                    folderBeingDeleted.workbooks.forEach(wb => delete newState[wb.id]);
                    return newState;
                });
            }
        }
    );
  }, [folders, expandedFolderId]); 

  const handleDeleteWorkbook = useCallback((folderId: string, workbookIdToDelete: string, workbookName: string) => {
    if (!folderId || !workbookIdToDelete) {
        setError("Cannot delete workbook: Invalid ID.");
        return;
    }
    openConfirmationModal(
        "Delete Workbook",
        `Are you sure you want to delete the workbook "${workbookName}"? This action cannot be undone.`,
        () => {
            setFolders(prevFolders => {
                const updatedFolders = prevFolders.map(folder => {
                    if (folder.id === folderId) {
                        return { ...folder, workbooks: folder.workbooks.filter(wb => wb.id !== workbookIdToDelete) };
                    }
                    return folder;
                });
                // Remove folder if it becomes empty
                return updatedFolders.filter(f => !(f.id === folderId && f.workbooks.length === 0));
            });

            setSuccessMessage(`Workbook "${workbookName}" deleted successfully.`);
             if (expandedWorkbookId === workbookIdToDelete) {
                setExpandedWorkbookId(null);
            }
            setSelectedSheetsForExport(prev => {
                const newState = {...prev};
                delete newState[workbookIdToDelete];
                return newState;
            });
        }
    );
  }, [expandedWorkbookId]); 

  const toggleFolderExpansion = (folderId: string) => {
    if (editingFolderId === folderId) return; 
    setExpandedFolderId(prevId => (prevId === folderId ? null : folderId));
    if (expandedFolderId !== folderId) {
        setExpandedWorkbookId(null); 
    }
  };

  const toggleWorkbookExpansion = (workbookId: string) => {
    setExpandedWorkbookId(prevId => (prevId === workbookId ? null : workbookId));
  };
  
  const handleEditFolderClick = useCallback((folder: ExploitFolder) => {
    setEditingFolderId(folder.id);
    setNewFolderNameInput(folder.originalName);
    setExpandedFolderId(folder.id); 
  }, []);

  const handleCancelEditFolderName = useCallback(() => {
    setEditingFolderId(null);
    setNewFolderNameInput('');
  }, []);

  const handleSaveFolderName = useCallback(() => {
    if (!editingFolderId || !newFolderNameInput.trim()) {
      setError("Folder name cannot be empty.");
      return;
    }
    const trimmedNewName = newFolderNameInput.trim();
    const normalizedNewName = trimmedNewName.toLowerCase();
    if (folders.some(f => f.id !== editingFolderId && f.name.toLowerCase() === normalizedNewName)) {
        setError(`Another folder with the name "${trimmedNewName}" already exists. Please choose a unique name.`);
        return;
    }
    setFolders(prevFolders =>
      prevFolders.map(f =>
        f.id === editingFolderId
          ? { ...f, name: normalizedNewName, originalName: trimmedNewName }
          : f
      ).sort((a,b) => a.originalName.localeCompare(b.originalName))
    );
    setSuccessMessage(`Folder name updated to "${trimmedNewName}".`);
    setEditingFolderId(null);
    setNewFolderNameInput('');
  }, [editingFolderId, newFolderNameInput, folders]);

  const handleSheetSelectionChange = useCallback((workbookId: string, sheetName: string, isSelected: boolean) => {
      setSelectedSheetsForExport(prev => ({
          ...prev,
          [workbookId]: {
              ...(prev[workbookId] || {}),
              [sheetName]: isSelected,
          }
      }));
  }, []);

  const handleSelectAllSheetsInWorkbook = useCallback((workbookId: string, selectAll: boolean) => {
      const targetWorkbook = folders.flatMap(f => f.workbooks).find(wb => wb.id === workbookId);
      if (targetWorkbook) {
          const newSheetSelections: Record<string, boolean> = {};
          targetWorkbook.sheets.forEach(sheet => {
              newSheetSelections[sheet.name] = selectAll;
          });
          setSelectedSheetsForExport(prev => ({
              ...prev,
              [workbookId]: newSheetSelections,
          }));
      }
  }, [folders]);

  const handleExportSelectedSheetsFromCurrentWorkbook = useCallback(() => {
    if (!expandedWorkbookId) {
        setError("No workbook selected for export.");
        return;
    }
    const currentWorkbook = folders.flatMap(f => f.workbooks).find(wb => wb.id === expandedWorkbookId);
    const selectedSheetNamesMap = selectedSheetsForExport[expandedWorkbookId];

    if (!currentWorkbook || !selectedSheetNamesMap) {
        setError("Could not find workbook or selected sheets information.");
        return;
    }

    const sheetsToExport = currentWorkbook.sheets.filter(sheet => selectedSheetNamesMap[sheet.name]);

    if (sheetsToExport.length === 0) {
        setError("No sheets selected for export from this workbook.");
        return;
    }

    setIsLoading(true);
    setError(null);
    setSuccessMessage(null);

    try {
        const xlsxLibrary = window.XLSX;
        if (!xlsxLibrary) throw new Error("XLSX library not loaded.");

        const newXlsxWorkbook = xlsxLibrary.utils.book_new();
        sheetsToExport.forEach(sheet => {
            // Use the stored raw worksheet object if available (for formatting/images)
            if (!sheet.worksheet) {
              console.warn(`Worksheet object for sheet "${sheet.name}" is missing. Formatting/images may be lost for this sheet. Reconstructing from data.`);
              // Fallback: reconstruct sheet from headers and data (loses formatting)
              const aoaData: (string | number | boolean | null)[][] = [
                sheet.headers.map(String), // Ensure headers are strings
                ...sheet.data
              ];
              const fallbackWorksheet = xlsxLibrary.utils.aoa_to_sheet(aoaData);
              xlsxLibrary.utils.book_append_sheet(newXlsxWorkbook, fallbackWorksheet, sheet.name);
            } else {
              // This is the preferred path, using the potentially rich worksheet object
              xlsxLibrary.utils.book_append_sheet(newXlsxWorkbook, sheet.worksheet, sheet.name);
            }
        });

        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const fileName = `Exported_${currentWorkbook.fileName.replace(/\.(xlsx?|xls)$/i, '')}_${timestamp}.xlsx`;
        xlsxLibrary.writeFile(newXlsxWorkbook, fileName);
        setSuccessMessage(`Successfully exported ${sheetsToExport.length} sheet(s) from "${currentWorkbook.fileName}" to "${fileName}".`);

    } catch (err) {
        console.error("Export error:", err);
        setError(err instanceof Error ? err.message : "An unknown error occurred during export.");
    } finally {
        setIsLoading(false);
    }
  }, [expandedWorkbookId, folders, selectedSheetsForExport]);


  const totalSelectedSheetsForConsolidation = useMemo(() => {
    let count = 0;
    Object.values(selectedSheetsForExport).forEach(workbookSelections => {
        Object.values(workbookSelections).forEach(isSelected => {
            if (isSelected) count++;
        });
    });
    return count;
  }, [selectedSheetsForExport]);

  const handleConsolidateAllSelectedSheets = useCallback(() => {
    if (totalSelectedSheetsForConsolidation === 0) {
        setError("No sheets selected across any workbooks for consolidation.");
        return;
    }
    setIsLoading(true);
    setError(null);
    setSuccessMessage(null);

    try {
        const xlsxLibrary = window.XLSX;
        if (!xlsxLibrary) throw new Error("XLSX library not loaded.");

        const consolidatedWorkbook = xlsxLibrary.utils.book_new();
        const usedSheetNamesInExport: Set<string> = new Set();
        let sheetsAddedCount = 0;

        folders.forEach(folder => {
            folder.workbooks.forEach(workbook => {
                const selectionsForThisWorkbook = selectedSheetsForExport[workbook.id];
                if (selectionsForThisWorkbook) {
                    workbook.sheets.forEach(sheet => {
                        if (selectionsForThisWorkbook[sheet.name]) {
                            let worksheetToAppend = sheet.worksheet;
                            if (!worksheetToAppend) {
                                console.warn(`Worksheet object for sheet "${sheet.name}" in workbook "${workbook.fileName}" is missing. Formatting/images may be lost. Reconstructing from data.`);
                                const aoaData = [sheet.headers.map(String), ...sheet.data]; // Ensure headers are strings
                                worksheetToAppend = xlsxLibrary.utils.aoa_to_sheet(aoaData); 
                            }

                            // Ensure unique sheet name in the consolidated workbook
                            let uniqueSheetName = `${workbook.fileName.replace(/\.(xlsx?|xls)$/i, '')} - ${sheet.name}`;
                            let nameSuffix = 1;
                            while (usedSheetNamesInExport.has(uniqueSheetName)) {
                                nameSuffix++;
                                uniqueSheetName = `${workbook.fileName.replace(/\.(xlsx?|xls)$/i, '')} - ${sheet.name} (${nameSuffix})`;
                            }
                             // Truncate sheet name if it's too long (Excel limit is 31 chars)
                            if (uniqueSheetName.length > 31) {
                                uniqueSheetName = uniqueSheetName.substring(0, 31);
                                // If truncated name clashes, add suffix again
                                nameSuffix = 1; 
                                let tempName = uniqueSheetName;
                                while (usedSheetNamesInExport.has(tempName)) {
                                     nameSuffix++;
                                     // Ensure suffix fits: 31 - (length of suffix) - (length of " ()")
                                     tempName = uniqueSheetName.substring(0, 31 - (String(nameSuffix).length + 3)) + `(${nameSuffix})`; 
                                }
                                uniqueSheetName = tempName;
                            }

                            xlsxLibrary.utils.book_append_sheet(consolidatedWorkbook, worksheetToAppend, uniqueSheetName);
                            usedSheetNamesInExport.add(uniqueSheetName);
                            sheetsAddedCount++;
                        }
                    });
                }
            });
        });
        
        if (sheetsAddedCount > 0) {
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const fileName = `Consolidated_Export_${timestamp}.xlsx`;
            xlsxLibrary.writeFile(consolidatedWorkbook, fileName);
            setSuccessMessage(`Successfully consolidated and exported ${sheetsAddedCount} sheet(s) to "${fileName}".`);
        } else {
            // This case should ideally not be hit if totalSelectedSheetsForConsolidation > 0
            setError("No sheets were actually found to add to the consolidated export, despite initial selection count.");
        }

    } catch (err) {
        console.error("Consolidated export error:", err);
        setError(err instanceof Error ? err.message : "An unknown error occurred during consolidated export.");
    } finally {
        setIsLoading(false);
    }
  }, [folders, selectedSheetsForExport, totalSelectedSheetsForConsolidation]);


  const isAnySheetSelectedInExpandedWorkbook = useMemo(() => {
      if (!expandedWorkbookId || !selectedSheetsForExport[expandedWorkbookId]) return false;
      return Object.values(selectedSheetsForExport[expandedWorkbookId]).some(isSelected => isSelected);
  }, [expandedWorkbookId, selectedSheetsForExport]);

  const areAllSheetsSelectedInExpandedWorkbook = useMemo(() => {
      if (!expandedWorkbookId) return false;
      const targetWorkbook = folders.flatMap(f => f.workbooks).find(wb => wb.id === expandedWorkbookId);
      if (!targetWorkbook || targetWorkbook.sheets.length === 0) return false; // No sheets to select all from
      
      const currentSelections = selectedSheetsForExport[expandedWorkbookId] || {};
      return targetWorkbook.sheets.every(sheet => currentSelections[sheet.name] === true) && targetWorkbook.sheets.length > 0;
  }, [expandedWorkbookId, selectedSheetsForExport, folders]);

  const countSelectedSheetsInWorkbook = (workbookId: string): number => {
      if (!selectedSheetsForExport[workbookId]) return 0;
      return Object.values(selectedSheetsForExport[workbookId]).filter(isSelected => isSelected).length;
  };


  return (
    <div className="p-4 md:p-6 lg:p-8 space-y-8">
      {showConfirmModal && confirmModalInfo && (
        <ConfirmModal
          isOpen={showConfirmModal}
          title={confirmModalInfo.title}
          message={confirmModalInfo.message}
          onConfirm={() => {
            confirmModalInfo.onConfirmAction();
            setShowConfirmModal(false);
            setConfirmModalInfo(null);
          }}
          onClose={() => {
            setShowConfirmModal(false);
            setConfirmModalInfo(null);
          }}
        />
      )}
      <header className="mb-2">
        <h1 className="text-4xl font-extrabold text-slate-900 tracking-tight">Exploit View</h1>
        <p className="text-lg text-slate-700 mt-1">Upload and explore your Excel workbooks. A PDF preview of uploaded files will also be generated.</p>
      </header>

      {(error || successMessage) && (
        <div className="fixed top-20 right-5 z-[250] w-full max-w-md p-1">
          {error && (
            <div role="alert">
              <div className="bg-red-600 text-white font-semibold rounded-t-lg px-4 py-2 shadow-xl flex items-center">
                <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}><path strokeLinecap="round" strokeLinejoin="round" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" /></svg>
                Error
              </div>
              <div className="border border-t-0 border-red-500 rounded-b-lg bg-red-100 px-4 py-3 text-red-700 shadow-xl"><p className="text-sm">{error}</p></div>
            </div>
          )}
          {successMessage && (
             <div role="alert">
              <div className="bg-green-600 text-white font-semibold rounded-t-lg px-4 py-2 shadow-xl flex items-center">
                <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}><path strokeLinecap="round" strokeLinejoin="round" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
                Success
              </div>
              <div className="border border-t-0 border-green-500 rounded-b-lg bg-green-100 px-4 py-3 text-green-700 shadow-xl"><p className="text-sm">{successMessage}</p></div>
            </div>
          )}
        </div>
      )}

      {showFolderModal && selectedFileForUpload && (
        <div className="fixed inset-0 bg-slate-800 bg-opacity-75 flex items-center justify-center z-[200] p-4 transition-opacity duration-300 ease-in-out" aria-modal="true" role="dialog" aria-labelledby="folder-modal-title">
          <div className="bg-white p-6 rounded-xl shadow-2xl w-full max-w-md transform transition-all duration-300 ease-in-out scale-100">
            <div className="flex justify-between items-center mb-4">
                <h2 id="folder-modal-title" className="text-xl font-semibold text-slate-800">Specify Folder for Upload</h2>
                <button onClick={() => {setShowFolderModal(false); setSelectedFileForUpload(null); if(fileInputRef.current) fileInputRef.current.value = "";}} className="p-1 text-slate-400 hover:text-slate-600" aria-label="Close modal">
                    <XMarkIcon className="w-6 h-6" />
                </button>
            </div>
            <p className="text-sm text-slate-600 mb-1">Uploading: <span className="font-semibold">{selectedFileForUpload.name}</span></p>
            
            <div className="mt-4">
              <label htmlFor="folderNameInput" className="block text-sm font-medium text-slate-700 mb-1">Folder Name:</label>
              <input
                type="text"
                id="folderNameInput"
                ref={folderNameInputRef}
                value={targetFolderName}
                onChange={(e) => setTargetFolderName(e.target.value)}
                placeholder="Enter new or existing folder name"
                className="w-full px-3 py-2 border border-slate-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-sky-500 focus:border-sky-500 sm:text-sm"
                list="existing-folders-list"
                required
              />
              {folders.length > 0 && (
                 <datalist id="existing-folders-list">
                    {folders.map(folder => (
                        <option key={folder.id} value={folder.originalName} />
                    ))}
                </datalist>
              )}
              <p className="text-xs text-slate-500 mt-1">Folder names are case-insensitive for matching.</p>
            </div>
            <div className="mt-6 flex justify-end space-x-3">
              <button
                type="button"
                onClick={() => {setShowFolderModal(false); setSelectedFileForUpload(null); if(fileInputRef.current) fileInputRef.current.value = "";}}
                className="px-4 py-2 text-sm font-medium text-slate-700 bg-slate-100 hover:bg-slate-200 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-slate-400"
              >
                Cancel
              </button>
              <button
                type="button"
                onClick={handleConfirmUploadWithFolder}
                disabled={isLoading || !targetFolderName.trim()}
                className="px-4 py-2 text-sm font-medium text-white bg-sky-600 hover:bg-sky-700 rounded-lg shadow-md focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-sky-500 disabled:opacity-60 disabled:cursor-not-allowed"
              >
                {isLoading ? 'Processing...' : 'Upload & Gen. PDF'}
              </button>
            </div>
          </div>
        </div>
      )}

      <section aria-labelledby="upload-section-title" className="bg-white p-6 rounded-xl shadow-2xl">
        <div className="grid grid-cols-1 md:grid-cols-2 gap-x-6 gap-y-4 items-start">
            <div>
                <h2 id="upload-section-title" className="text-xl font-semibold text-slate-800 mb-3 flex items-center">
                    <UploadIcon className="w-6 h-6 mr-2 text-sky-600" />
                    Upload Excel Workbook
                </h2>
                <label htmlFor="excel-upload" className={`inline-flex items-center px-5 py-3 bg-sky-600 text-white text-sm font-semibold rounded-lg shadow-md hover:bg-sky-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-sky-500 cursor-pointer transition-all duration-150 ease-in-out transform hover:scale-105 ${isLoading ? 'opacity-60 cursor-not-allowed' : ''}`}>
                    <UploadIcon className="w-5 h-5 mr-2" />
                    {isLoading && !showFolderModal ? 'Processing...' : 'Select Excel File (.xls, .xlsx)'}
                </label>
                <input
                    id="excel-upload" type="file" ref={fileInputRef} className="hidden"
                    onChange={handleFileSelect}
                    accept=".xls,.xlsx,application/vnd.ms-excel,application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
                    disabled={isLoading} aria-describedby="upload-description"
                />
                <p id="upload-description" className="mt-1.5 text-xs text-slate-600">
                    A basic PDF preview will be downloaded. Full Excel data is processed locally and stored in browser.
                </p>
            </div>
            <div className="md:border-l md:pl-6 border-slate-200">
                <h2 className="text-xl font-semibold text-slate-800 mb-3 flex items-center">
                   <ArchiveBoxArrowDownIcon className="w-6 h-6 mr-2 text-indigo-600" />
                    Consolidated Excel Export
                </h2>
                <button
                    onClick={handleConsolidateAllSelectedSheets}
                    disabled={isLoading || totalSelectedSheetsForConsolidation === 0}
                    className="inline-flex items-center px-5 py-3 bg-indigo-600 text-white text-sm font-semibold rounded-lg shadow-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition-all duration-150 ease-in-out transform hover:scale-105 disabled:opacity-60 disabled:cursor-not-allowed"
                    title={totalSelectedSheetsForConsolidation > 0 ? `Export ${totalSelectedSheetsForConsolidation} selected sheet(s) into one file` : "No sheets selected globally to export"}
                >
                    <ArchiveBoxArrowDownIcon className="w-5 h-5 mr-2" />
                    Consolidate All Selected ({totalSelectedSheetsForConsolidation})
                </button>
                 <p className="mt-1.5 text-xs text-slate-600">
                    Export all sheets selected across various workbooks into a single new Excel file.
                </p>
            </div>
        </div>
      </section>

      <section aria-labelledby="folders-list-title">
        <h2 id="folders-list-title" className="text-2xl font-semibold text-slate-800 my-6">
          Uploaded Folders & Workbooks
        </h2>
        {isLoading && folders.length === 0 && !showFolderModal && (
            <div className="text-center p-6 bg-white rounded-xl shadow-lg">
                <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-sky-600 mx-auto"></div>
                <p className="mt-4 text-slate-600">Processing...</p>
            </div>
        )}
        {!isLoading && folders.length === 0 && (
          <div className="text-center p-10 bg-white rounded-xl shadow-xl flex flex-col items-center">
            <InformationCircleIcon className="w-16 h-16 text-sky-500 mb-4" />
            <p className="text-slate-800 text-xl font-medium">No folders or workbooks uploaded yet.</p>
            <p className="text-slate-700 mt-2">Use the upload button above to add Excel files into folders.</p>
          </div>
        )}

        {folders.length > 0 && (
          <div className="space-y-6">
            {folders.map(folder => (
              <div key={folder.id} className="bg-white rounded-xl shadow-2xl overflow-hidden transition-all duration-300 ease-in-out hover:shadow-3xl group/folder-card">
                <div className="p-5 flex justify-between items-center border-b border-slate-200 group-hover/folder-card:bg-slate-50/70">
                  {editingFolderId === folder.id ? (
                     <div className="flex-grow flex items-center space-x-2">
                        <FolderOpenIcon className="w-8 h-8 text-sky-600 mr-2 flex-shrink-0" />
                        <input 
                            type="text" 
                            ref={editFolderNameInputRef}
                            value={newFolderNameInput}
                            onChange={(e) => setNewFolderNameInput(e.target.value)}
                            onKeyDown={(e) => { if (e.key === 'Enter') handleSaveFolderName(); if (e.key === 'Escape') handleCancelEditFolderName();}}
                            className="text-lg font-semibold text-slate-800 px-2 py-1 border border-sky-500 rounded-md shadow-sm w-full focus:ring-2 focus:ring-sky-500"
                            aria-label="Edit folder name"
                        />
                    </div>
                  ) : (
                    <div 
                        className="flex items-center flex-grow cursor-pointer"
                        onClick={() => toggleFolderExpansion(folder.id)} role="button" tabIndex={0}
                        onKeyDown={(e) => (e.key === 'Enter' || e.key === ' ') && toggleFolderExpansion(folder.id)}
                        aria-expanded={expandedFolderId === folder.id} aria-controls={`workbooks-in-${folder.id}`}
                    >
                        {expandedFolderId === folder.id ? <FolderOpenIcon className="w-8 h-8 text-sky-600 mr-4 flex-shrink-0" /> : <FolderIcon className="w-8 h-8 text-sky-600 mr-4 flex-shrink-0" />}
                        <div className="flex-grow">
                        <h3 className="text-lg font-semibold text-slate-800 truncate" title={folder.originalName}>{folder.originalName}</h3>
                        <p className="text-xs text-slate-500">
                            {folder.workbooks.length} workbook(s) &bull; Created: {folder.createdAt.toLocaleDateString()}
                        </p>
                        </div>
                    </div>
                  )}
                  <div className="flex items-center space-x-1 sm:space-x-2 ml-2 sm:ml-4 flex-shrink-0">
                    {editingFolderId === folder.id ? (
                        <>
                            <button
                                onClick={handleSaveFolderName}
                                className="p-2 text-green-500 hover:text-green-700 hover:bg-green-100 rounded-full transition-colors duration-150"
                                aria-label="Save folder name" title="Save name" disabled={isLoading}
                            > <SaveIcon className="w-5 h-5" /> </button>
                            <button
                                onClick={handleCancelEditFolderName}
                                className="p-2 text-red-500 hover:text-red-700 hover:bg-red-100 rounded-full transition-colors duration-150"
                                aria-label="Cancel editing folder name" title="Cancel edit" disabled={isLoading}
                            > <XMarkIcon className="w-5 h-5" /> </button>
                        </>
                    ) : (
                        <button
                            onClick={(e) => { e.stopPropagation(); handleEditFolderClick(folder); }}
                            className="p-2 text-slate-400 hover:text-sky-600 hover:bg-sky-100 rounded-full transition-colors duration-150 opacity-0 group-hover/folder-card:opacity-100 focus:opacity-100"
                            aria-label={`Edit folder name ${folder.originalName}`} title={`Edit name of ${folder.originalName}`} disabled={isLoading}
                        > <EditIcon className="w-5 h-5" /> </button>
                    )}
                    <button
                      onClick={(e) => { e.stopPropagation(); handleDeleteFolder(folder.id, folder.originalName); }}
                      className="p-2 text-slate-400 hover:text-red-600 hover:bg-red-100 rounded-full transition-colors duration-150 opacity-0 group-hover/folder-card:opacity-100 focus:opacity-100"
                      aria-label={`Delete folder ${folder.originalName}`} title={`Delete ${folder.originalName}`} disabled={isLoading || editingFolderId === folder.id}
                    > <TrashIcon className="w-5 h-5" /> </button>
                    <button 
                      onClick={() => { if (editingFolderId !== folder.id) toggleFolderExpansion(folder.id); }}
                      className={`p-2 text-slate-400 hover:text-sky-600 hover:bg-sky-100 rounded-full transition-colors duration-150 ${editingFolderId === folder.id ? 'opacity-50 cursor-not-allowed' : ''}`}
                      aria-label={expandedFolderId === folder.id ? 'Collapse folder' : 'Expand folder'}
                      disabled={editingFolderId === folder.id}
                    > 
                      {expandedFolderId === folder.id ? <ChevronUpIcon className="w-6 h-6" /> : <ChevronDownIcon className="w-6 h-6" />}
                    </button>
                  </div>
                </div>

                {expandedFolderId === folder.id && (
                  <div id={`workbooks-in-${folder.id}`} className="p-4 md:p-5 border-t border-slate-200 bg-slate-50/30 space-y-3">
                    {folder.workbooks.length === 0 && (
                      <p className="text-sm text-slate-500 italic px-2 py-1">No workbooks in this folder.</p>
                    )}
                    {folder.workbooks.map(workbook => (
                      <div key={workbook.id} className="bg-white rounded-lg shadow-lg hover:shadow-xl transition-shadow duration-200 group/workbook-card">
                        <div className="p-3 sm:p-4 flex justify-between items-center border-b border-slate-100 group-hover/workbook-card:bg-sky-50/50">
                          <div 
                            className="flex items-center flex-grow cursor-pointer min-w-0" 
                            onClick={() => toggleWorkbookExpansion(workbook.id)} role="button" tabIndex={0}
                            onKeyDown={(e) => (e.key === 'Enter' || e.key === ' ') && toggleWorkbookExpansion(workbook.id)}
                            aria-expanded={expandedWorkbookId === workbook.id} aria-controls={`sheets-in-${workbook.id}`}
                          >
                            {expandedWorkbookId === workbook.id ? <ChevronUpIcon className="w-5 h-5 text-sky-500 mr-3 flex-shrink-0" /> : <ChevronDownIcon className="w-5 h-5 text-sky-500 mr-3 flex-shrink-0" />}
                            <DocumentIcon className="w-6 h-6 text-emerald-600 mr-3 flex-shrink-0" />
                            <div className="flex-grow min-w-0"> 
                              <h4 className="text-md font-medium text-slate-700 group-hover/workbook-card:text-sky-700 truncate" title={workbook.fileName}>{workbook.fileName}</h4>
                              <p className="text-xs text-slate-500">
                                {workbook.sheets.length} sheet(s) &bull; Uploaded: {workbook.uploadedAt.toLocaleTimeString()}
                              </p>
                            </div>
                          </div>
                          <button
                            onClick={(e) => { e.stopPropagation(); handleDeleteWorkbook(folder.id, workbook.id, workbook.fileName);}}
                            className="p-1.5 text-slate-400 hover:text-red-500 hover:bg-red-50 rounded-full transition-colors duration-150 ml-2 opacity-0 group-hover/workbook-card:opacity-100 focus:opacity-100 flex-shrink-0"
                            aria-label={`Delete workbook ${workbook.fileName}`} title={`Delete ${workbook.fileName}`} disabled={isLoading}
                          > <TrashIcon className="w-4 h-4" /> </button>
                        </div>
                        {expandedWorkbookId === workbook.id && (
                          <div id={`sheets-in-${workbook.id}`} className="p-3 sm:p-4 bg-slate-25/50">
                             <div className="flex justify-between items-center mb-2.5 ml-1">
                                <div className="flex items-center">
                                  <input
                                    type="checkbox"
                                    id={`select-all-${workbook.id}`}
                                    checked={areAllSheetsSelectedInExpandedWorkbook}
                                    onChange={(e) => handleSelectAllSheetsInWorkbook(workbook.id, e.target.checked)}
                                    className="h-4 w-4 text-sky-600 border-slate-400 rounded focus:ring-sky-500 mr-2"
                                    disabled={workbook.sheets.length === 0 || isLoading}
                                    aria-labelledby={`select-all-label-${workbook.id}`}
                                  />
                                  <label id={`select-all-label-${workbook.id}`} htmlFor={`select-all-${workbook.id}`} className="text-xs font-medium text-slate-600 select-none cursor-pointer">
                                    Select All ({countSelectedSheetsInWorkbook(workbook.id)} / {workbook.sheets.length})
                                  </label>
                                </div>
                                <button
                                  onClick={handleExportSelectedSheetsFromCurrentWorkbook}
                                  disabled={!isAnySheetSelectedInExpandedWorkbook || isLoading}
                                  className="inline-flex items-center px-3 py-1.5 bg-emerald-500 text-white text-xs font-semibold rounded-md shadow-sm hover:bg-emerald-600 focus:outline-none focus:ring-2 focus:ring-offset-1 focus:ring-emerald-500 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
                                  title={isAnySheetSelectedInExpandedWorkbook ? "Export selected sheets from this workbook" : "Select sheets to export"}
                                >
                                  <DownloadIcon className="w-4 h-4 mr-1.5" /> Export Workbook Sel.
                                </button>
                              </div>
                            
                            <h5 className="text-sm font-semibold text-slate-600 mb-2 ml-1 mt-3">Sheets:</h5>
                            {workbook.sheets.length === 0 && <p className="text-xs text-slate-500 italic ml-1">No sheets found in this workbook.</p>}
                            <ul className="space-y-1.5 max-h-60 overflow-y-auto pr-1">
                              {workbook.sheets.map(sheet => (
                                <li key={sheet.name} className="flex items-center p-2 bg-slate-100 rounded hover:bg-sky-100 transition-colors duration-150">
                                  <input
                                    type="checkbox"
                                    id={`sheet-select-${workbook.id}-${sheet.name.replace(/\s+/g, '-')}`}
                                    checked={!!selectedSheetsForExport[workbook.id]?.[sheet.name]}
                                    onChange={(e) => handleSheetSelectionChange(workbook.id, sheet.name, e.target.checked)}
                                    className="h-4 w-4 text-sky-600 border-slate-400 rounded focus:ring-sky-500 mr-2.5 flex-shrink-0"
                                    disabled={isLoading}
                                    aria-labelledby={`sheet-label-${workbook.id}-${sheet.name.replace(/\s+/g, '-')}`}
                                  />
                                  <DocumentIcon className="w-4 h-4 text-slate-500 mr-2.5 flex-shrink-0" />
                                  <label id={`sheet-label-${workbook.id}-${sheet.name.replace(/\s+/g, '-')}`} htmlFor={`sheet-select-${workbook.id}-${sheet.name.replace(/\s+/g, '-')}`} className="text-sm text-slate-700 truncate cursor-pointer select-none flex-grow" title={sheet.name}>
                                    {sheet.name}
                                  </label>
                                  <span className="ml-auto text-xs text-slate-500 whitespace-nowrap">({sheet.data.length} data rows)</span>
                                </li>
                              ))}
                            </ul>
                          </div>
                        )}
                      </div>
                    ))}
                  </div>
                )}
              </div>
            ))}
          </div>
        )}
      </section>
    </div>
  );
};
